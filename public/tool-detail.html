<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üîß Tool Detail | ConRad AI</title>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0a0f;
      --bg-panel: #12121a;
      --bg-card: #1a1a24;
      --border: #2a2a3a;
      --text: #e4e4e7;
      --text-dim: #71717a;
      --accent-cyan: #06b6d4;
      --accent-purple: #a855f7;
      --accent-green: #22c55e;
      --accent-yellow: #eab308;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      min-height: 100vh;
      padding: 40px;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--text-dim);
      text-decoration: none;
      margin-bottom: 30px;
      font-size: 14px;
    }
    
    .back-btn:hover { color: var(--accent-cyan); }
    
    .tool-header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .tool-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
    }
    
    .tool-title h1 {
      font-size: 28px;
      margin-bottom: 8px;
    }
    
    .tool-title p {
      color: var(--text-dim);
      font-size: 16px;
    }
    
    .tool-badge {
      display: inline-block;
      background: var(--bg-card);
      border: 1px solid var(--accent-cyan);
      color: var(--accent-cyan);
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 11px;
      font-weight: 600;
      margin-top: 8px;
    }
    
    .section {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
    }
    
    .section h2 {
      font-size: 16px;
      color: var(--accent-cyan);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .code-block {
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 20px;
      font-family: 'Fira Code', monospace;
      font-size: 13px;
      line-height: 1.8;
      overflow-x: auto;
    }
    
    .code-comment { color: #6b7280; }
    .code-keyword { color: var(--accent-purple); }
    .code-string { color: var(--accent-green); }
    .code-function { color: var(--accent-cyan); }
    .code-number { color: var(--accent-yellow); }
    
    .step {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      padding: 16px;
      background: var(--bg-card);
      border-radius: 10px;
      border-left: 3px solid var(--accent-cyan);
    }
    
    .step-num {
      width: 30px;
      height: 30px;
      background: var(--accent-cyan);
      color: var(--bg-dark);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      flex-shrink: 0;
    }
    
    .step-content h4 {
      font-size: 14px;
      margin-bottom: 6px;
    }
    
    .step-content p {
      color: var(--text-dim);
      font-size: 13px;
    }
    
    .step-content code {
      background: var(--bg-panel);
      padding: 2px 8px;
      border-radius: 4px;
      color: var(--accent-cyan);
      font-family: 'Fira Code', monospace;
      font-size: 12px;
    }
    
    .params-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .params-table th, .params-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    
    .params-table th {
      color: var(--text-dim);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }
    
    .params-table td {
      font-size: 13px;
    }
    
    .param-name {
      font-family: 'Fira Code', monospace;
      color: var(--accent-purple);
    }
    
    .param-type {
      color: var(--accent-cyan);
      font-size: 12px;
    }
    
    .data-sources {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    
    .data-source {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 13px;
    }
    
    .data-source.csv { border-color: var(--accent-green); }
    .data-source.json { border-color: var(--accent-purple); }
    .data-source.api { border-color: var(--accent-cyan); }
    
    .related-tools {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    
    .related-tool {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      text-decoration: none;
      color: var(--text);
      transition: all 0.2s;
    }
    
    .related-tool:hover {
      border-color: var(--accent-cyan);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="/agent-orchestration.html" class="back-btn">‚Üê Back to Orchestration</a>
    
    <div id="toolContent">
      <!-- Populated by JS -->
    </div>
  </div>

<script>
const TOOLS = {
  search_portals: {
    name: 'search_portals',
    icon: 'üåê',
    description: 'Searches government and industrial portals for RFPs matching criteria using permutation-based filtering',
    category: 'Search & Discovery',
    agent: 'Sales Agent',
    steps: [
      { title: 'Load Portal Data', desc: 'Read tender data from <code>gov.json</code>, <code>industrial.json</code>, <code>utilities.json</code>' },
      { title: 'Parse Cable Type', desc: 'Detect cable type from query: HT, LT, Control, EHV, Instrumentation' },
      { title: 'Generate Permutations', desc: 'Create search combinations from CSV: <code>cableType √ó voltage √ó city</code>' },
      { title: 'Filter by Deadline', desc: 'Apply date filter: <code>due_date > today AND due_date < today + 90 days</code>' },
      { title: 'Match Requirements', desc: 'Compare <code>cable_requirements[]</code> array in each tender against search filters' },
      { title: 'Rank Results', desc: 'Sort by: deadline proximity √ó estimated value √ó material match' }
    ],
    params: [
      { name: 'cableType', type: 'string', desc: 'Cable type to search (HT, LT, Control, etc.)' },
      { name: 'voltage', type: 'string', desc: 'Voltage rating filter (e.g., "11kV", "33kV")' },
      { name: 'city', type: 'string', desc: 'City/location filter (e.g., "Mumbai", "Delhi")' },
      { name: 'portal', type: 'string', desc: 'Specific portal to search (gov, industrial, utilities)' }
    ],
    dataSources: [
      { name: 'ht_cables.csv', type: 'csv' },
      { name: 'lt_cables.csv', type: 'csv' },
      { name: 'control_cables.csv', type: 'csv' },
      { name: 'ehv_cables.csv', type: 'csv' },
      { name: 'gov.json', type: 'json' },
      { name: 'industrial.json', type: 'json' }
    ],
    code: `// Permutation Generation Logic
const CSV_PATHS = {
  'ht': 'data/products/ht_cables.csv',
  'lt': 'data/products/lt_cables.csv',
  'control': 'data/products/control_cables.csv',
  'ehv': 'data/products/ehv_cables.csv'
};

function generatePermutations(cableType, filters) {
  const products = parseCSV(CSV_PATHS[cableType]);
  const voltages = getUniqueVoltages(products);
  const cities = getAvailableCities();
  
  // Generate all combinations
  const permutations = [];
  voltages.forEach(voltage => {
    cities.forEach(city => {
      permutations.push({
        cableType: getCableTypeLabel(cableType),
        voltage: voltage,
        city: city,
        keyword: \`\${cableType} cable \${voltage} \${city}\`
      });
    });
  });
  
  return permutations;
}`,
    relatedTools: ['extract_pdf_data', 'semantic_product_search']
  },
  
  extract_pdf_data: {
    name: 'extract_pdf_data',
    icon: 'üìÑ',
    description: 'Extracts structured data from RFP PDFs using adaptive document learning',
    category: 'Document Processing',
    agent: 'Sales Agent',
    steps: [
      { title: 'Load PDF Text', desc: 'Extract raw text from PDF using pdf-parse or AWS Textract' },
      { title: 'Load Document Templates', desc: 'Read learned templates from <code>document_knowledge.json</code>' },
      { title: 'Classify Sections', desc: 'Identify sections: <code>BOQ</code>, <code>Specifications</code>, <code>Terms</code>, <code>Submission</code>' },
      { title: 'Extract Key Fields', desc: 'Pull: tender_id, organisation, due_date, estimated_cost, cable_requirements[]' },
      { title: 'Parse BOQ Table', desc: 'Extract line items with quantity, specifications, unit from BOQ section' },
      { title: 'Return Structured JSON', desc: 'Output standardized RFP object with confidence scores' }
    ],
    params: [
      { name: 'pdfPath', type: 'string', desc: 'Path to the PDF file' },
      { name: 'useTextract', type: 'boolean', desc: 'Whether to use AWS Textract for scanned PDFs' }
    ],
    dataSources: [
      { name: 'document_knowledge.json', type: 'json' },
      { name: 'AWS Textract API', type: 'api' }
    ],
    code: `// Document Structure Learning
async function extractFromDocument(pdfText) {
  // Load learned document templates
  const templates = loadDocumentKnowledge();
  
  // Split into sections
  const sections = classifySections(pdfText, templates);
  
  // Extract structured data
  const extracted = {
    tender_id: extractTenderId(sections),
    organisation: extractOrganisation(sections),
    due_date: extractDueDate(sections),
    cable_requirements: extractBOQ(sections.boq),
    terms: extractTerms(sections.terms),
    submission: extractSubmissionInfo(sections)
  };
  
  // Learn from this document for future
  await learnDocumentStructure(pdfText, extracted);
  
  return extracted;
}`,
    relatedTools: ['search_portals', 'match_specifications']
  },
  
  semantic_product_search: {
    name: 'semantic_product_search',
    icon: 'üîç',
    description: 'Finds products using AI embeddings for semantic similarity matching',
    category: 'AI Matching',
    agent: 'Technical Agent',
    steps: [
      { title: 'Load Embedding Model', desc: 'Initialize <code>all-MiniLM-L6-v2</code> (384-dimensional vectors)' },
      { title: 'Embed Query', desc: 'Convert search query to vector: <code>embed("HT cable 11kV copper 240sqmm")</code>' },
      { title: 'Load Product Embeddings', desc: 'Read pre-computed embeddings from <code>embeddings_cache.json</code>' },
      { title: 'Calculate Similarity', desc: 'Compute cosine similarity: <code>cos(queryVec, productVec)</code>' },
      { title: 'Apply Domain Weights', desc: 'Boost scores using fine-tuned domain vocabulary weights' },
      { title: 'Return Top Matches', desc: 'Filter by similarity > 0.6, sort descending, return top K' }
    ],
    params: [
      { name: 'query', type: 'string', desc: 'Natural language search query' },
      { name: 'topK', type: 'number', desc: 'Number of results to return (default: 10)' }
    ],
    dataSources: [
      { name: 'embeddings_cache.json', type: 'json' },
      { name: 'ht_cables.csv', type: 'csv' },
      { name: 'lt_cables.csv', type: 'csv' }
    ],
    code: `// Semantic Search with Local Embeddings
import { embed, cosineSimilarity } from './local-embeddings.js';

async function semanticProductSearch(query, topK = 10) {
  // Embed the query
  const queryEmbedding = await embed(query);
  
  // Load cached product embeddings
  const cache = loadEmbeddingsCache();
  
  // Calculate similarities
  const results = [];
  for (const [productId, productEmbed] of Object.entries(cache.products)) {
    const similarity = cosineSimilarity(queryEmbedding, productEmbed.embedding);
    if (similarity > 0.6) {
      results.push({
        sku: productId,
        product: productEmbed.product,
        similarity: similarity
      });
    }
  }
  
  // Sort and return top K
  return results
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, topK);
}`,
    relatedTools: ['match_specifications', 'get_product_schema']
  },
  
  match_specifications: {
    name: 'match_specifications',
    icon: 'üéØ',
    description: 'Compares RFP specs against OEM product specifications with equal weightage',
    category: 'Technical Analysis',
    agent: 'Technical Agent',
    steps: [
      { title: 'Parse RFP Specs', desc: 'Extract: voltage, cores, cross-section, material, insulation, armour type' },
      { title: 'Load Product Catalog', desc: 'Read from HT/LT/Control cable CSVs based on detected type' },
      { title: 'Compare Each Spec', desc: 'Check: <code>exact match OR within tolerance range</code>' },
      { title: 'Apply Tolerances', desc: 'Voltage: ¬±10%, Cross-section area: ¬±15%, Cores: exact match' },
      { title: 'Calculate Match %', desc: '<code>Spec Match = (matched_specs / total_specs) √ó 100</code>' },
      { title: 'Return Best Matches', desc: 'Sort by match percentage, include comparison table' }
    ],
    params: [
      { name: 'rfpSpecs', type: 'object', desc: 'RFP specification requirements' },
      { name: 'candidateSKUs', type: 'array', desc: 'List of SKU IDs to compare against' }
    ],
    dataSources: [
      { name: 'ht_cables.csv', type: 'csv' },
      { name: 'lt_cables.csv', type: 'csv' },
      { name: 'control_cables.csv', type: 'csv' }
    ],
    code: `// Specification Matching with Equal Weightage
function matchSpecifications(rfpSpecs, product) {
  const specs = ['voltage', 'cores', 'area', 'material', 'insulation'];
  let matched = 0;
  const comparison = {};
  
  specs.forEach(spec => {
    const rfpVal = rfpSpecs[spec];
    const prodVal = product[spec];
    
    // Check match with tolerance
    const isMatch = checkWithTolerance(rfpVal, prodVal, spec);
    comparison[spec] = { rfp: rfpVal, product: prodVal, match: isMatch };
    if (isMatch) matched++;
  });
  
  return {
    matchPercentage: (matched / specs.length) * 100,
    comparison: comparison,
    canBid: matched >= Math.ceil(specs.length * 0.7)
  };
}`,
    relatedTools: ['semantic_product_search', 'calculate_pricing']
  },
  
  calculate_pricing: {
    name: 'calculate_pricing',
    icon: 'üí∞',
    description: 'Calculates quotation with material cost, testing charges, and GST',
    category: 'Pricing & Quotation',
    agent: 'Pricing Agent',
    steps: [
      { title: 'Load Product Prices', desc: 'Read unit prices from <code>pricing_rules.csv</code> or cable CSVs' },
      { title: 'Calculate Material Cost', desc: '<code>Material = Unit_Price_per_km √ó quantity_km</code>' },
      { title: 'Add Routine Tests', desc: 'Include: Conductor Resistance, HV Test, Insulation Resistance' },
      { title: 'Check Type Tests', desc: 'Add type tests if project value > ‚Çπ50 Lakhs' },
      { title: 'Calculate GST', desc: '<code>GST = Subtotal √ó 0.18</code> (18% GST rate)' },
      { title: 'Generate Quotation', desc: 'Grand Total = Material + Tests + GST' }
    ],
    params: [
      { name: 'lineItems', type: 'array', desc: 'Array of {sku, quantity_km} items' },
      { name: 'includeTypeTesting', type: 'boolean', desc: 'Whether to include type testing costs' }
    ],
    dataSources: [
      { name: 'pricing_rules.csv', type: 'csv' },
      { name: 'testing.csv', type: 'csv' }
    ],
    code: `// Pricing Calculation
function calculateQuotation(lineItems, includeTypeTesting = false) {
  let materialCost = 0;
  let testingCost = 0;
  
  lineItems.forEach(item => {
    const product = loadProduct(item.sku);
    materialCost += product.Unit_Price_per_km * item.quantity_km;
    
    // Add routine tests
    testingCost += getRoutineTestCost(product.Type);
  });
  
  // Type tests for large projects
  if (includeTypeTesting || materialCost > 5000000) {
    testingCost += getTypeTestCost();
  }
  
  const subtotal = materialCost + testingCost;
  const gst = subtotal * 0.18;
  
  return {
    materialCost,
    testingCost,
    subtotal,
    gst,
    grandTotal: subtotal + gst
  };
}`,
    relatedTools: ['match_specifications', 'generate_quotation']
  }
};

// Get tool from URL params
const params = new URLSearchParams(window.location.search);
const toolName = params.get('tool') || 'search_portals';
const tool = TOOLS[toolName] || TOOLS.search_portals;

// Render tool detail
function renderTool() {
  const container = document.getElementById('toolContent');
  
  container.innerHTML = `
    <div class="tool-header">
      <div class="tool-icon">${tool.icon}</div>
      <div class="tool-title">
        <h1>${tool.name}()</h1>
        <p>${tool.description}</p>
        <span class="tool-badge">${tool.agent} ‚Ä¢ ${tool.category}</span>
      </div>
    </div>
    
    <div class="section">
      <h2>‚öôÔ∏è How It Works</h2>
      ${tool.steps.map((step, i) => `
        <div class="step">
          <div class="step-num">${i + 1}</div>
          <div class="step-content">
            <h4>${step.title}</h4>
            <p>${step.desc}</p>
          </div>
        </div>
      `).join('')}
    </div>
    
    <div class="section">
      <h2>üì• Parameters</h2>
      <table class="params-table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          ${tool.params.map(p => `
            <tr>
              <td class="param-name">${p.name}</td>
              <td class="param-type">${p.type}</td>
              <td>${p.desc}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </div>
    
    <div class="section">
      <h2>üìä Data Sources Used</h2>
      <div class="data-sources">
        ${tool.dataSources.map(ds => `
          <div class="data-source ${ds.type}">
            <span>${ds.type === 'csv' ? 'üìä' : ds.type === 'json' ? 'üìÅ' : 'üåê'}</span>
            <span>${ds.name}</span>
          </div>
        `).join('')}
      </div>
    </div>
    
    <div class="section">
      <h2>üíª Implementation</h2>
      <div class="code-block">
        <pre>${tool.code}</pre>
      </div>
    </div>
    
    <div class="section">
      <h2>üîó Related Tools</h2>
      <div class="related-tools">
        ${tool.relatedTools.map(rt => {
          const relatedTool = TOOLS[rt];
          return relatedTool ? `
            <a href="/tool-detail.html?tool=${rt}" class="related-tool">
              <span style="font-size: 24px;">${relatedTool.icon}</span>
              <div>
                <div style="font-weight: 600;">${relatedTool.name}</div>
                <div style="font-size: 11px; color: var(--text-dim);">${relatedTool.category}</div>
              </div>
            </a>
          ` : '';
        }).join('')}
      </div>
    </div>
  `;
}

renderTool();
</script>
</body>
</html>



